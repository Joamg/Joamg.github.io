<!-- 随机数组  Array(100).fill(0).map(it => Math.random() * 100 | 0) -->
<script> // 对数组第i和j项进行对调
  function swap(array, i, j) {
    var t = array[i]
    array[i] = array[j]
    array[j] = t
    return array
}
</script>
<script> //冒泡排序 
/**
 * 时间复杂度: O(n * n)
 * 空间复杂度: O(1)   
 */
  function bubbleSort(array) {
      for (j = 0; j < array.length - 1; j++) {
      var swapped = false            //引入swapeed是为了判断是否进入了第二层循环就不用继续进入了 直接break
      for (i = 0; i < array.length - 1 - j; i++) {
        if (array[i] > array[i + 1]) {
          swapped = true            
           var t = array[i]         //引入t的作用是t作为中转对array[i] 和array[i + 1]进行互换位置
          array[i] = array[i + 1]                                      
          array[i + 1] = t  
        } 
      }  
      if(!swapped) {
        break
      }
    }
    return array
  }
</script>

<script> //选择排序
/**
 * 时间复杂度: O(n * n)
 * 空间复杂度: O(1)   
 */
  function selectSort(array) {
    for (j = 0; j < array.length - 1; j++) {
      var minIndex = j          
        for (var i = j + 1; i < array.length; i++) {  
        if(array[i] < array[minIndex]) {        
          minIndex = i                    //寻找最大值的下标
        }
      }
      var t = array[j]
      array[j] = array[minIndex]
      array[minIndex] = t
    }
      return array
  }
</script>

<script> //插入排序
/**
 * 插入顺序: 将无序部分的第一个数插入到有序部分的正确位置
 * 时间复杂度: O(n * n)
 * 空间复杂度: O(1)   
 */
  function insertSort(array) {
    for (var i = 1; i < array.length; i++) {
      var t = array[i]
      for (var j = i - 1; j >= 0; j--) {
        if(array[j] > t) {
          array[j + 1] = array[j]
        } else {
          break
        }
      }
      array[j + 1] = t
    }
    return array
  }


</script>

<script>//归并排序
  function mergeSort(array) {
    if (array.length < 2) {
      return array
    }
    var midIdx = array.length >> 1
    var leftArray = array.slice(0, midIdx)
    var rightArray = array.slice(midIdx)
    leftArray = mergeSort(leftArray)
    rightArray = mergeSort(rightArray)

    var i = 0
    var j = 0
    var k = 0
    while (i < leftArray.length && j < rightArray.length) {
      if(leftArray[i] < rightArray[j]) {
        array[k++] = leftArray[i++]
      } else {
        array[k++] = rightArray[j++]
      }
    }

    while (i < leftArray.length) {
      array[k++] = leftArray[i++] 
    }
    while (j < rightArray.length) {
      array[k++] = rightArray[j++] 
    }
    return array
  }
</script>

<!-- <script> //快速排序 (五分做法 空间复杂度O(n))
  function quickSort(array) {
    var randIdx= Math.floor(Math.random() * array.length) //确定数组随机的下标; Math.random的范围是0-1
    var randItem = array[randIdx]               //这两行是为了从数组里面随机抽取一个数
    var a =[] //小于randItemd的数字组成的数组
    var b = [] //等于randItem的数字组成的数组
    var c = [] //大于randItem的数字组成的数组
    for (var i = 0; i < array.length; i++) {
      if (array[i] < randItem) {
        a.push(array[i])
      }
    } else if (array[i] > randItem) {
        c.push(array[i])
    } else {
      b.push(array[i])
    }
    a = quickSort(a)
    c = quickSort(c)
    return a.concat(b, c)
  }
</script> -->


<script> //快速排序
  function quickSort(array, start = 0, end = array.length - 1) {
    if(end - start < 1) {  //递归的结束条件
      return array
    } 
    var pivotIdx = Math.floor(Math.random() * (end - start + 1)) + start  //随机挑选一个哨兵元素
    var pivot = array[pivotIdx]
    swap(array, pivotIdx, end) //对哨兵元素跟最后一个元素进行对调, 将最后一个座位哨兵元素
    var i = start
    var j = start
    for (; j < end; j++) {   //如果
      if(array[j] < pivot) {
        swap(array, i++, j)
      }
    }
    swap(array, i, end)
    quickSort(array, start, i - 1)
    quickSort(array, i + 1, end)
    return array
  }
</script>






